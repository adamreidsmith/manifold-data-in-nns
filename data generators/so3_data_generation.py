#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Aug  1 10:08:19 2019

@author: noelmurasko
"""
import numpy as np
from scipy.integrate import odeint

def generate_data(I, n, tn, noise_level, start_time = 0, end_time = 10,
                  tolerance = 10**-4, Oi_min = -1, Oi_max = 1,
                  torque1 = lambda t:0, torque2 = lambda t:0, torque3 = lambda t:0):
    
    '''
    The following function takes a takes 3 principle moments of intertia and
    creates a time series of 3X3 Orientation matrices. The orientation matrices
    are transformed into euler angle and gaussian white noise is added. The
    noisy euler angles are then transformed back into 3X3 Orientation matrices.
    
    Required Parameters:
        
        - I is a 3 element array with three principle moments 
            of inertia ([I1, I2, I3]).

        - n are the number of time series generated by the function.

        - tn are the number of time steps in each time series.
    
        - noise level is the standard deviation of the gaussian white
            noise addded to the euler angles.
            
    Optional Parameters:  
        
        - start_time is the start time for each time series.
            The default value is 0.
        
        - end_time is the end time for each time series.
            The default value is 10.
        
        - tolerance is the tollerence level for orthogonality and determinant
            checks. As each matrix should be in SO(3), we check that it's
            transpose is sufficiently close (within the tollerance level)
            to it's inverse and that it's determinant is sufficiently close to
            one. The default value is 10^-4.
        
        - Oi_min and Oi_max are the minimum and maximum values the components
            of the angular velocity can take. In each time series they are
            randomly generated. Their default values are -1 and 1 respectively.
        
        - torque1, torque2, and torque3 are values for torque acting on the
            system. They must be functions of time. Their default values are
            zero (free body motion). Note: Some forcing functions may result in 
            matrices that not close enough to being in SO(3) for the default
            tolerance. 
            
    Returns: 
    
        - List of n arrays. Each array in the list has dimensions (tn , 3, 3)
            and is a time series of 3X3 orientation matrices.
    '''
    
    def make_orientation_matrix(I,Li,t,ep,tol):
        #Computes the orientation matrices over a given time 
        
        '''Oi = np.array([np.random.uniform(Oi_min,Oi_max),
                       np.random.uniform(Oi_min,Oi_max),
                       np.random.uniform(Oi_min,Oi_max)])'''
        Oi = np.array([-0.5, 0.3, 0.8])
        
        #We then create a vector yi of initial values
        yi = np.append(Oi, np.reshape(Li,(1,9)))

        #We compute the angular velocities and elements of orientation matrices 
        #based on initial conditions
        y = odeint(ydot, yi, t, args=(I[0],I[1],I[2]))
        
        
        #We then get the orientation matrices from y
        L = get_lambdas(y,len(t))


        #We then map the matrices to euler angles, add noise terms, and map
        #back to orientation matrices
        Ln = make_noise(L,ep,tol,len(t))

        return Ln

    def ydot(y,t,I1,I2,I3):
        '''
        This differential equation solves both omega and lambda simultaneously.
        The arguments I1, I2, I3 are principle moments of inertia. O_1, O_2,
        O_3 are the respective angular velocities. Letters d through l are the 
        9 components of the orientation matrix.
        '''
        
        O1, O2, O3, d, e, f, g, h, i, j, k, l = y
        
        dOdt = [torque1(t)/I1 + (I2-I3)*O2*O3/I1,
                torque2(t)/I2 + (I3-I1)*O1*O3/I2,
                torque3(t)/I3 + (I1-I2)*O1*O2/I3,
                e*O3-f*O2 ,f*O1-d*O3, d*O2-e*O1,
                h*O3 - i*O2, i*O1 - g*O3, g*O2 - h*O1,
                k*O3-l*O2, l*O1-j*O3, j*O2 - k*O1]

        return dOdt

    def get_lambdas(y,n):
        '''
        This function takes an array y of size 12 and outputs a 3 by 3 matrix 
        using the last 9 entries of y at each time t. Each of these matrices is
        appended to a tuple L which is returned.
        '''
        L = []

        for i in range(n):
            L.append(np.reshape(y[i][3:12],(3,3)))

        return L    

    def or_to_eu(R,ep):
    #This function converts a given 3x3 rotation matrix into euler angles.
    #It is based off a paper by Gregory G. Slabaugh.

      #We check that R is orthogonal
      ortho_check = check_orthogonality(R)

      #We check that R is special
      det_check = check_specialness(R)

      if ortho_check > ep:
          print('Your Matrix is not Orthogonal.')
          exit()

      elif det_check > ep:
          print('Your Matrix is not Special.')
          exit()

      elif abs(R[2][0]) != 1:
          a1 = -np.arcsin(R[2][0])
          b1 = np.arctan2(R[2][1]/np.cos(a1),R[2][2]/np.cos(a1))
          c1 = np.arctan2(R[1][0]/np.cos(a1),R[0][0]/np.cos(a1))

          return [a1,b1,c1]

      else:
          #c can be anything. We set it to zero.
          c = 0
          if R[2][0] == -1:
              print('k')
              a = np.pi/2
              b = c + np.arctan2(R[0][1],R[0][2])
              return [a,b,c]
          else:
              print('j')
              a = -np.pi/2
              b = -c + np.arctan2(-R[0][1],-R[0][2])
              return [a,b,c]

    def noisy(V,ep):
        #compute random noise and add it to values
        n_0 = np.random.normal(0,1)
        n_1 = np.random.normal(0,1)
        n_2 = np.random.normal(0,1)

        U = [0,0,0]

        U[0] = V[0] + ep*n_0
        U[1] = V[1] + ep*n_1
        U[2] = V[2] + ep*n_2

        return U

    def eu_to_or(V):
        #converts euler angles into rotation matrices.
        a = V[0]
        b = V[1]
        c = V[2]

        #We compute the rotation matrices using the angles defined by 
        #Slabaugh
        R_1 = np.array([[1,0,0],[0,np.cos(b),-np.sin(b)],
                        [0,np.sin(b),np.cos(b)]])
        R_2 = np.array([[np.cos(a),0,np.sin(a)],[0,1,0],
                         [-np.sin(a),0,np.cos(a)]])
        R_3 = np.array([[np.cos(c),-np.sin(c),0],[np.sin(c),
                         np.cos(c),0],[0,0,1]])

        #We multiply the matrices to obtain the orientation matrix. The order 
        #of multiplication is the one used to determine the euler angles in the 
        #first place.
        R = np.matmul(R_3,np.matmul(R_2,R_1))

        return R

    def make_noise(R,ep,tol,n):
        L_n = []
        for i in range(n): 
            q_angles = or_to_eu(R[i],tol)
            n_angles = noisy(q_angles,ep)
            ln = eu_to_or(n_angles)
            L_n.append(ln)
        L_n = np.array(L_n)
        return L_n


    def make_moments(minimum,maximum):
        #Moments of inertia (can be any non-negative real number)
        I1 = np.random.uniform(minimum,maximum)
        I2 = np.random.uniform(minimum,maximum)
        I3 = np.random.uniform(minimum,maximum)
        while I1+I2<I3 or I1+I3<I2 or I2+I3<I1:
            I3 = np.random.uniform(minimum,maximum)

        return [I1,I2,I3]

    def check_orthogonality(M):
        MT = M.transpose()
        #We check that M is orthogonal
        ortho_check = np.amax(abs(np.matmul(MT,M) - np.identity(3)))
        return ortho_check

    def check_specialness(M):
        #We check that R is special
        det_check = 1 - abs(np.linalg.det(M))
        return det_check
        
    i = n
    #initialize data
    data = []

    #time data points
    t = np.linspace(start_time,end_time,tn)
    
    #Initial conditions for orientation matrix
    Li = np.identity(3)
    
    #append moments of inertia and matrices to data list
    while i>0:
        #Initial conditions for angular velocity
        Ln = make_orientation_matrix(I, Li, t, noise_level, tolerance)
        i -= 1
        data.append(Ln)
        
    return data